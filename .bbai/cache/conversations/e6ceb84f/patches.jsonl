{"timestamp":"2024-08-13T05:34:21.307Z","filePath":"main.py","patch":"```diff\n--- a/main.py\n+++ b/main.py\n@@ -7,6 +7,8 @@ import tornado.websocket\n import os\n from datetime import datetime\n import uuid\n+import logging\n+import shutil\n import re\n \n def strip_xml_tags(text):\n@@ -43,18 +45,35 @@ def send_email(transcript, story, recipient):\n         st.error(f\"An error occurred while sending the email: {str(e)}\")\n         return False\n \n+# Set up logging\n+logging.basicConfig(filename='chatbot.log', level=logging.INFO,\n+                    format='%(asctime)s - %(levelname)s - %(message)s')\n+\n+# Create a directory for conversation files if it doesn't exist\n+CONVERSATION_DIR = \"conversations\"\n+os.makedirs(CONVERSATION_DIR, exist_ok=True)\n+\n # Function to save new messages to the current conversation file\n def save_conversation(new_messages, conversation_id):\n-    filename = f\"conversation_{conversation_id}.txt\"\n+    filename = os.path.join(CONVERSATION_DIR, f\"conversation_{conversation_id}.txt\")\n     try:\n         with open(filename, \"a\") as f:\n             timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n             if os.path.getsize(filename) == 0:\n                 f.write(f\"Conversation started at {timestamp}\\n\\n\")\n+                logging.info(f\"New conversation file created: {filename}\")\n             else:\n                 f.write(f\"\\n--- New messages at {timestamp} ---\\n\")\n             for message in new_messages:\n                 f.write(f\"{message['role']}: {message['content']}\\n\")\n+        logging.info(f\"Conversation updated: {filename}\")\n+    except IOError as e:\n+        error_msg = f\"IOError occurred while saving the conversation: {str(e)}\"\n+        logging.error(error_msg)\n+        st.error(error_msg)\n     except Exception as e:\n-        st.error(f\"An error occurred while saving the conversation: {str(e)}\")\n+        error_msg = f\"An unexpected error occurred while saving the conversation: {str(e)}\"\n+        logging.error(error_msg)\n+        st.error(error_msg)\n+\n+# Function to clean up old conversation files (older than 30 days)\n+def cleanup_old_conversations():\n+    current_time = datetime.now()\n+    for filename in os.listdir(CONVERSATION_DIR):\n+        file_path = os.path.join(CONVERSATION_DIR, filename)\n+        file_modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))\n+        if (current_time - file_modified_time).days > 30:\n+            os.remove(file_path)\n+            logging.info(f\"Removed old conversation file: {file_path}\")\n+\n+# Run cleanup at the start of each session\n+cleanup_old_conversations()\n \n def end_conversation():\n     \"\"\"Handle the end of the conversation, including sending the email.\"\"\"\n@@ -68,10 +87,12 @@ def end_conversation():\n     try:\n         send_email(transcript, \"\", email_receiver)\n         st.success('Thank you for the conversation. The transcript has been sent via email.')\n+        logging.info(f\"Conversation ended and email sent for conversation ID: {st.session_state.conversation_id}\")\n         # Reset the conversation\n         st.session_state.conversation_history = []\n         st.session_state.conversation_id = str(uuid.uuid4())\n     except Exception as e:\n+        logging.error(f\"Error ending conversation: {str(e)}\")\n         st.error(f\"An error occurred while ending the conversation: {e}\")\n \n st.title(\"Sales Interviewer\")\n```"}
{"timestamp":"2024-08-13T05:36:56.582Z","filePath":"main.py","patch":"[{\"search\":\"import shutil\",\"replace\":\"\"},{\"search\":\"# Function to clean up old conversation files (older than 30 days)\\ndef cleanup_old_conversations():\\n    current_time = datetime.now()\\n    for filename in os.listdir(CONVERSATION_DIR):\\n        file_path = os.path.join(CONVERSATION_DIR, filename)\\n        file_modified_time = datetime.fromtimestamp(os.path.getmtime(file_path))\\n        if (current_time - file_modified_time).days > 30:\\n            os.remove(file_path)\\n            logging.info(f\\\"Removed old conversation file: {file_path}\\\")\\n\\n# Run cleanup at the start of each session\\ncleanup_old_conversations()\",\"replace\":\"\"}]"}
{"timestamp":"2024-08-13T05:43:45.513Z","filePath":"main.py","patch":"```diff\n--- a/main.py\n+++ b/main.py\n@@ -76,11 +76,10 @@ def save_conversation(new_messages, conversation_id):\n         logging.error(error_msg)\n         st.error(error_msg)\n \n-\n-\n-        logging.info(f\"Conversation ended and email sent for conversation ID: {st.session_state.conversation_id}\")\n def end_conversation():\n     \"\"\"Handle the end of the conversation, including sending the email.\"\"\"\n+    logging.info(f\"Attempting to end conversation for ID: {st.session_state.conversation_id}\")\n+    \n     transcript = \"\\n\".join([f\"{message['role']}: {message['content']}\" for message in st.session_state.conversation_history])\n     \n-    logging.error(f\"Error ending conversation: {str(e)}\")\n     email_sender = st.secrets[\"EMAIL_USER\"]\n     email_receiver = \"alexcarpenter2000@gmail.com\"\n     subject = \"Sales Interview Transcript\"\n@@ -89,11 +88,13 @@ def end_conversation():\n     try:\n         send_email(transcript, \"\", email_receiver)\n         st.success('Thank you for the conversation. The transcript has been sent via email.')\n+        logging.info(f\"Conversation ended and email sent for conversation ID: {st.session_state.conversation_id}\")\n         # Reset the conversation\n         st.session_state.conversation_history = []\n         st.session_state.conversation_id = str(uuid.uuid4())\n     except Exception as e:\n-        st.error(f\"An error occurred while ending the conversation: {e}\")\n+        error_msg = f\"An error occurred while ending the conversation: {str(e)}\"\n+        logging.error(error_msg)\n+        st.error(error_msg)\n \n st.title(\"Sales Interviewer\")\n```"}
{"timestamp":"2024-08-13T05:55:42.851Z","filePath":"main.py","patch":"```diff\n--- a/main.py\n+++ b/main.py\n@@ -166,7 +166,7 @@ if prompt:\n     save_conversation([{\"role\": \"user\", \"content\": prompt}], st.session_state.conversation_id)\n \n     # Generate assistant response only if the last message in the conversation history is from the user\n-if st.session_state.conversation_history[-1][\"role\"] == \"user\":\n+if st.session_state.conversation_history and st.session_state.conversation_history[-1][\"role\"] == \"user\":\n     response_text = \"\"\n     try:\n         response = client.messages.create(\n```"}
